  #include "MotorController.h"
  #include "ros2.h"

  extern portMUX_TYPE mux;  // Mutex for critical section defined in odometry.cpp

  MotorController::MotorController(int8_t ForwardPin, int8_t BackwardPin, /* int8_t EnablePin, /* int8_t EncoderA, int8_t EncoderB, */ int tickPerRevolution) {
    this->Forward = ForwardPin;
    this->Backward = BackwardPin;
    //this->EncoderPinA = EncoderA;
    //this->EncoderPinB = EncoderB;
    this->tick = tickPerRevolution;
    pinMode(Forward, OUTPUT);
    pinMode(Backward, OUTPUT);
    //pinMode(EncoderPinA, INPUT);
    //pinMode(EncoderPinB, INPUT);
    corruptions = 0;
  }

  //initializing the parameters of PID controller
  void MotorController::initPID(float proportionalGain, float integralGain, float derivativeGain) {
    kp = proportionalGain;
    ki = integralGain;
    kd = derivativeGain;
  }

  //function return rpm of the motor using the encoder tick values
  float MotorController::getRpm(volatile int * encoder_count_total) {

    portENTER_CRITICAL(&mux);  // Disable interrupts
    int ect = * encoder_count_total;
    if(* encoder_count_total > 1000000){ // it can happen that encoder_count_total be corrupted during interrupt
        printf("getRpm got a corrupted encoder_count_total=%d Set it at the previous value %d \r\n",
          *encoder_count_total, PreviousPosition);
        *encoder_count_total = PreviousPosition;
        corruptions ++;
    }
    portEXIT_CRITICAL(&mux);   // Re-enable interrupts

    CurrentPosition = ect;
    CurrentTime = millis();
    float delta1 = ((float)(CurrentTime - PreviousTime)) / 1.0e3;
    if(delta1 < 1.0e-6) // avoid division by zero
      return NAN;
    float velocity = ((float)(CurrentPosition - PreviousPosition)) / delta1;
    float rpm = (velocity / (float) tick) * 60.0;
    //rpmFilt = 0.854 * rpmFilt + 0.0728 * rpm + 0.0728 * rpmPrev;
    rpmFilt = rpm;
    //float rpmPrev = rpm;
    PreviousPosition = CurrentPosition;
    PreviousTime = CurrentTime;
    // Serial.println(rpmFilt);
    return rpmFilt;
  }

  //pid controller
  float MotorController::pid(float setpoint, float feedback) {
    CurrentTimeforError = millis();
    float delta2 = ((float)CurrentTimeforError - (float)PreviousTimeForError) / 1.0e3;
    if(delta2 == 0.0)
      return NAN;  
    error = setpoint - feedback;
    eintegral = eintegral + (error * delta2);
    ederivative = (error - previousError) / delta2;
    float control_signal = (kp * error) + (ki * eintegral) + (kd * ederivative);
    previousError = error;
    PreviousTimeForError = CurrentTimeforError;
    return control_signal;
  }
  //move the robot wheels based the control signal generated by the pid controller
  void MotorController::moveBase(float ActuatingSignal, int threshold, int pwmChannel0, int pwmChannel1 ) {

    int pwm = threshold + (int)fabs(ActuatingSignal);
    if (pwm > 255)
      pwm = 255;

    if (ActuatingSignal > 0) {
      ledcWrite(pwmChannel0, pwm);
      ledcWrite(pwmChannel1, 0);
    } else {
      ledcWrite(pwmChannel0, 0);
      ledcWrite(pwmChannel1, pwm);
   }
  }
  void MotorController::stop(int pwmChannel0, int pwmChannel1) {
    ledcWrite(pwmChannel0, 0);
    ledcWrite(pwmChannel1, 0);
  }

  // void plot(float Value1, float Value2){
  //     Serial.print("Value1:");
  //     Serial.print(Value1);
  //     Serial.print(",");
  //     Serial.print("value2:");
  //     Serial.println(Value2);
  // }

  
